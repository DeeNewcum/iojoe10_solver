- This points out that A* can be FAST or ACCURATE but not both.
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#speed-or-accuracy
  Because of my dogged pursuit of speed, it's likely I will end up compromising accuracy.
  Therefore, I need metrics that show exactly how much accuracy is compromised, to make sure
  I don't overdo it.

  TODO: Add a "optimal moves" field to every board, that is manually-entered.  It's the number of
        moves in an optimal solution.  Then when we report the final statistics, report
        how much longer the found-solution is than the optimal field.


- Add an "alpha" parameter as a cmdline parameter, as mentioned here:
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#speed-or-accuracy
        https://en.wikipedia.org/wiki/A*_search_algorithm#Bounded_relaxation


- Implement IsUnsolvable::geographically_isolated().
  Test it on:
        Inverting-11
        Blocks-12

- Are there any ways to improve the heuristic?  That seems like one of the best ways to speed up A*.

        - have it prioritize combining  9s and 8s (and maybe 1s?) over other combinations

        - Is there any way to extract the data when IsUnsolvable::noclipping_mark3 knows FOR SURE
          that two or more blocks need to combine eventually?  If so, we should *absolutely*
          prioritize those before any other moves.

- possible constant-time optimizations:

    - install Class::XSAccessor   (Moo says it can speed things up if this is installed)


- release to a few people:

    - contact the author, see if they're interested in this at all
            (it's very possible they have already built their own)

                https://twitter.com/10TheGame
                https://twitter.com/iojoetweets
                http://www.iojoe.com/about.html     simon @ iojoe.com


    - post in some other places:
                http://jayisgames.com/archives/2013/10/10.php


- A* seems to be taking more time-per-move than IDDFS.
  I'm not sure this is a fair comparison, however.  IDDFS visits nodes several times, and there
  are several caching mechanisms in the algorithm.  These caches will make IDDFS appear to be faster
  (per-move) than A*, but this is an illusion.

        - If the IDDFS metric is inaccurate, then we haven't been getting proper information about
          how much of a time-penalty we get from hashing or other "optional" features.
          TODO: Re-evaluate these on A* instead.


- Create a new series of boards for inclusion with the game, called "10 is Routing".
  The emphasis here is on path-finding / routing pieces through a path, and providing little
  structures that allow 1) pieces to exchange positions, 2) T-branches so they can go one way or the
  other, etc.

  The board Hard-13 is a great example of this kind of board.  However, it is a bit hard, and there
  should be a ramp-up in difficulty, levels that are a little less hard, for the player to learn
  from.


- attach a screenshot of the program working

    - use Github Pages to host the screenshot:   http://oli.jp/2011/github-pages-workflow/

    - Maybe I want to find some way to compress the solution listing though....
        make it wider.     Use Term::Readkey?   http://stackoverflow.com/a/1782149/1042525
        Or just assume it's 80 cols wide, in which case we can fit 5 boards wide...





- notes from implementing A*:

    "A* search is one of the best general-purpose graph search algorithms when there's a way to
    estimate the distance to the goal"

    http://www.autonlab.org/tutorials/astar08.pdf
    http://www.gamasutra.com/view/feature/131724/smart_move_intelligent_.php?page=5
    http://www.youtube.com/playlist?list=PL473C810C4140E164

    articles with pseudocode, or have discussions of implementation details:
        https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode
        http://www.policyalmanac.org/games/aStarTutorial.htm
        http://web.mit.edu/eranki/www/tutorials/search/
        http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html
