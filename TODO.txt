- Wow, IsUnsolvable::noclipping() is consuming a LOT of CPU, especially when piece-count is high
  (because it's O(n^2).
  In some cases, it consumes the vast majority of time it takes to find a solution.
  (eg. for Inverting-3, even with _noclipping_shortcut, 90% of the solution time is spent on it)

    - spend more time gathering metrics, and trying to optimize this!

    - also, gather RAM usage data -- if this pukes on a 2GB box, we at least want to know about that

    - also, confirm that this routine saves time -- it would suck if it's actually consuming more
      time than it saves


- There's a bug when displaying the final solution for Multiplying-16.   There's several 
  "use of uninitialized value" errors.


- This points out that A* can be FAST or ACCURATE but not both.
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#speed-or-accuracy
  Because of my dogged pursuit of speed, it's likely I will end up compromising accuracy.
  Therefore, I need metrics that show exactly how much accuracy is compromised, to make sure
  I don't overdo it.

  TODO: Add a "optimal moves" field to every board, that is manually-entered.  It's the number of
        moves in an optimal solution.  Then when we report the final statistics, report
        how much longer the found-solution is than the optimal field.


- Add a --relax cmdline parameter, as mentioned here:
        http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#speed-or-accuracy
        https://en.wikipedia.org/wiki/A*_search_algorithm#Bounded_relaxation


- Implement IsUnsolvable::geographically_isolated().
  Test it on:
        Inverting-11
        Blocks-12

- Are there any ways to improve the heuristic?  That seems like one of the best ways to speed up A*.

        - have it prioritize combining  9s and 8s (and maybe 1s?) over other combinations

        - Is there any way to extract the data when IsUnsolvable::noclipping_mark3 knows FOR SURE
          that two or more blocks need to combine eventually?  If so, we should *absolutely*
          prioritize those before any other moves.


- Are there any ways to improve the algorithm, other than the heuristic?

        - Is there any way to apply Jump Point Search to "10"?
          What if we 1) *imagined* that we could move pieces around, without being 100% confident
          that we could, 2) explored whether that gets us closer to the destination, and 
          3) if it DOES get us closer to the destination, then we go back and double-check that
          the mental leap taken in Step #1 is actually possible?
                  http://harablog.wordpress.com/2011/09/07/jump-point-search/


- possible constant-time optimizations:

    - install Class::XSAccessor   (Moo says it can speed things up if this is installed)


- release to a few people:

    - contact the author, see if they're interested in this at all
            (it's very possible they have already built their own)

                https://twitter.com/10TheGame
                https://twitter.com/iojoetweets
                http://www.iojoe.com/about.html     simon @ iojoe.com


    - post in some other places:
                http://jayisgames.com/archives/2013/10/10.php



- Create a new series of boards for inclusion with the game, called "10 is Routing".
  The emphasis here is on path-finding / routing pieces through a path, and providing little
  structures that allow 1) pieces to exchange positions, 2) T-branches so they can go one way or the
  other, etc.

  The board Hard-13 is a great example of this kind of board.  However, it is a bit hard, and there
  should be a ramp-up in difficulty, levels that are a little less hard, for the player to learn
  from.


- attach a screenshot of the program working

    - use Github Pages to host the screenshot:   http://oli.jp/2011/github-pages-workflow/

    - Maybe I want to find some way to compress the solution listing though....
        make it wider.     Use Term::Readkey?   http://stackoverflow.com/a/1782149/1042525
        Or just assume it's 80 cols wide, in which case we can fit 5 boards wide...




- The "number of moves" metric is incorrect at the very beginning of a large board.  A* actually
  evaluates ALL first-level moves, always, up-front.  It looks like the current metric only counts
  moves after we pull them off of the open set.  We should change this so it counts moves AS they're
  being put onto the open set.


- Notes about time-per-move in A* versus IDDFS:
  A* seems to take more time-per-move than IDDFS.  I'm not sure this is a fair comparison, however.
  IDDFS visits nodes several times, and there are several caching mechanisms in the algorithm.
  These caches will make IDDFS appear to be faster (per-move) than A*, but this is an illusion.

        - If the IDDFS metric is inaccurate, then we haven't been getting proper information about
          how much of a time-penalty we get from fingerprinting or other "optional" features.
          TODO: Re-evaluate these on A* instead.


- notes from implementing A*:

    "A* search is one of the best general-purpose graph search algorithms when there's a way to
    estimate the distance to the goal"

    http://www.cs.ualberta.ca/~tony/RecentPapers/Draft.5.2.pdf
    http://www.autonlab.org/tutorials/astar08.pdf
    http://www.gamasutra.com/view/feature/131724/smart_move_intelligent_.php?page=5
    https://en.wikibooks.org/wiki/Artificial_Intelligence/Search/Heuristic_search/Astar_Search
    http://www.youtube.com/playlist?list=PL473C810C4140E164
    http://heyes-jones.com/astar.php
    http://www.gamasutra.com/view/feature/131505/toward_more_realistic_pathfinding.php?print=1

    articles with pseudocode, or have discussions of implementation details:
        https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode
        http://www.policyalmanac.org/games/aStarTutorial.htm
        http://web.mit.edu/eranki/www/tutorials/search/
        http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html
        http://wiki.gamegardens.com/Path_Finding_Tutorial#Pseudo-code_A.2A

    advice on optimizing A*, making it FASTER
        http://www.seas.upenn.edu/~cis568/presentations/AStar.pdf
        http://harablog.wordpress.com/2011/09/07/jump-point-search/

